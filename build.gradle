/*
 * Copyright 2019 MovingBlocks
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * This is a Gradle build file:
 * - Gradle Homepage: http://gradle.org/
 * - Gradle Documentation: http://gradle.org/documentation
 * - View tasks for this project: $ gradlew tasks
 */

buildscript {
    repositories {
        mavenCentral()
        jcenter()
        maven { url "https://plugins.gradle.org/m2/" }
    }
    dependencies {
        //TODO: replace with google/archive-patcher?
        classpath group: "com.alexkasko.delta", name: "delta-diff", version: "1.1.3"
    }
}

plugins {
    id 'application'
    id 'checkstyle'
    id 'com.github.spotbugs' version '1.6.9'
    id 'de.undercouch.download' version '3.4.3' // TODO: upgrade to latest version (191011: 4.0.0)
    id 'eclipse'
    id 'idea'
    id 'java'
    id 'org.hidetake.swagger.generator' version '2.18.1'
    id 'pmd'
    id 'project-report'
    id 'org.openjfx.javafxplugin' version '0.0.8'
    id 'org.beryx.jlink' version '2.17.0'
    id 'org.javamodularity.moduleplugin' version '1.5.0'
}

apply from: "./config/gradle/jre.gradle"
// TODO salvage useful bits and remove this
//apply from: "./config/gradle/bundles.gradle"
apply from: "./config/gradle/quality.gradle"
apply from: "./config/gradle/swagger.gradle"
apply from: "./config/gradle/environment.gradle"

// Test for right version of Java in use for running this script
assert JavaVersion.current().isJava11Compatible()

// gradle wrapper version
wrapper {
    gradleVersion '5.4.1'
}


import org.apache.tools.ant.filters.FixCrLfFilter

import java.text.SimpleDateFormat

def dateTimeFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX")
dateTimeFormat.timeZone = TimeZone.getTimeZone("UTC")

def getDisplayVersion = { env, versionBase ->
    if (env.JOB_NAME == "TerasologyLauncherStable") {
        versionBase
    } else if (env.JOB_NAME != null && env.BUILD_NUMBER != null) {
        versionBase + '.' + env.BUILD_NUMBER + '+' + env.JOB_NAME
    } else {
        versionBase + ' local development ' + startDateTimeString
    }
}

// Declare "extra properties" (variables) for the project - a Gradle thing that makes them special.
ext {
    // Read environment variables, including variables passed by jenkins continuous integration server
    env = System.getenv()

    // Stuff for our automatic version file setup
    startDateTimeString = dateTimeFormat.format(new Date())
    versionInfoFileDir = new File(sourceSets.main.output.resourcesDir, 'org/terasology/launcher/version')
    versionInfoFile = new File(versionInfoFileDir, 'versionInfo.properties')
    versionBase = rootProject.file("version.txt").text.trim()
    displayVersion = getDisplayVersion(env, versionBase)

    // Splash image for the JAR
    splashImage = "org/terasology/launcher/images/splash.jpg"
}

// Declare remote repositories we're interested in - library files will be fetched from here
repositories {
    // Main Maven repo
    mavenCentral()
    // MovingBlocks Artifactory instance(s) for libs not readily available elsewhere plus our own libs
    maven { url "http://artifactory.terasology.org/artifactory/virtual-repo-live" }
    jcenter()
}

// Primary dependencies definition
dependencies {
    compile group: 'org.slf4j', name: 'slf4j-api', version: '2.0.0-alpha1'
    compile group: 'net.java.dev.jna', name: 'jna', version: '4.1.0'
    compile group: 'net.java.dev.jna', name: 'jna-platform', version: '4.1.0'
    compile group: 'org.terasology', name: 'CrashReporter', version: '1.2.+'
    compile group: 'com.github.rjeschke', name: 'txtmark', version: '0.11'

    compile group: 'com.google.code.gson', name: 'gson', version: '2.8.5'
    compile (group: 'ch.qos.logback', name: 'logback-classic', version: '1.3.0-alpha4') {
        exclude module: "activation"
    }

    implementation("com.google.guava:guava:28.1-jre") {
        // conflictiong in module-info.java...
        exclude group: 'org.checkerframework', module: 'checker-qual'
        exclude group: 'com.google.code.findbugs', module: 'jsr305'
    }

    // For Web API
    // TODO: extract swagger dependencies into swagger.gradle
    swaggerCodegen 'io.swagger.codegen.v3:swagger-codegen-cli:3.0.5'
    if (new File('web-api-client').exists()) {
        compile project(':web-api-client')
    }

    // These dependencies are only needed for running tests
    testCompile group: 'junit', name: 'junit', version: '4.11'
    testCompile group: 'org.mockito', name: 'mockito-core', version: '2.26.0'
    testCompile group: 'org.mockito', name: 'mockito-inline', version: '2.26.0' // For final classes

    testCompile 'org.powermock:powermock-module-junit4:2.0.4'
    testCompile 'org.powermock:powermock-api-mockito2:2.0.2'
}

// Set the expected module Java level (can use a higher Java to run, but should not use features from a higher Java)
sourceCompatibility = 1.11
targetCompatibility = 1.11

javafx {
    version = "11.0.2"
    modules = [
            'javafx.graphics',
            'javafx.fxml',
            'javafx.web']
}

jlink {
    launcher {
        name = 'launcher'
    }
}

// exclude module info files for Java 9
checkstyleMain.exclude "**/module-info.java"
checkstyleTest.exclude "**/module-info.java"

test {
    useJUnit()
    moduleOptions {
        runOnClasspath = true
    }
}

mainClassName = 'org.terasology.launcher/org.terasology.launcher.TerasologyLauncher'

// Bundle JRE (Use gradle argument: -PbundleJre=/path/to/jre)
if (project.hasProperty('bundleJre')) {
    applicationDistribution.from("$bundleJre") {
        into 'jre'
    }

    startScripts {
        doLast {
            unixScript.text = unixScript.text.replaceFirst(/(?s)# Determine the Java.*(?=\R# Increase)/,
                    '# Use bundled JRE\nJAVACMD=\\$APP_HOME/jre/bin/java\n')

            windowsScript.text = windowsScript.text.replaceFirst(/(?s)@rem Find java.*:init/,
                    '@rem Use bundled JRE\nset JAVA_EXE=' + /%APP_HOME%\\jre\\bin\\java.exe/ + '\n')
        }
    }
}

def convertGitBranch = { gitBranch ->
    if (gitBranch != null) {
        // Remove "origin/" from "origin/develop"
        gitBranch.substring(gitBranch.lastIndexOf("/") + 1)
    } else {
        ""
    }
}

task createVersionInfoFile {
    inputs.property('dateTime', startDateTimeString)
    onlyIf { env.BUILD_URL != null }
    doLast {
        versionInfoFileDir.mkdirs()
        ant.propertyfile(file: versionInfoFile) {
            ant.entry(key: 'buildNumber', value: env.BUILD_NUMBER)
            ant.entry(key: 'buildId', value: env.BUILD_ID)
            ant.entry(key: 'buildTag', value: env.BUILD_TAG)
            ant.entry(key: 'buildUrl', value: env.BUILD_URL)
            ant.entry(key: 'jobName', value: env.JOB_NAME)
            ant.entry(key: 'gitBranch', value: convertGitBranch(env.GIT_BRANCH))
            ant.entry(key: 'gitCommit', value: env.GIT_COMMIT)
            ant.entry(key: 'dateTime', value: startDateTimeString)
            ant.entry(key: 'displayVersion', value: displayVersion)
        }
    }
}
createVersionInfoFile.dependsOn processResources
jar.dependsOn createVersionInfoFile
distZip.dependsOn createVersionInfoFile
distTar.dependsOn createVersionInfoFile

jar {
    // replace development "logback.xml" with productive "logback_jar.xml"
    exclude "logback.xml"
    rename('logback_jar.xml', 'logback.xml')
    manifest {
        def manifestClasspath = configurations.runtime.collect { it.getName() }.join(" ")
        attributes("Main-Class": mainClassName)
        attributes("Class-Path": manifestClasspath)
        attributes("Implementation-Title": project.name)
        attributes("Implementation-Version": versionBase)  // Use base version only to avoid re-creating identical jar
        attributes("SplashScreen-Image": splashImage)

        // allow everything
        attributes('Permissions': 'all-permissions')
        attributes('Codebase': '*')
        attributes('Application-Name': project.name)
        attributes('Application-Library-Allowable-Codebase': '*')
        attributes('Caller-Allowable-Codebase': '*')
        attributes('Trusted-Only': 'false')
    }
}

task copyExtra(type: Copy) {
    filter(FixCrLfFilter, eol: FixCrLfFilter.CrLf.newInstance("crlf"))

    from('README.md') {
        rename('README.md', 'README.txt')
    }

    from('CHANGELOG.md') {
        rename('CHANGELOG.md', 'CHANGELOG.txt')
    }

    from('CONTRIBUTING.md') {
        rename('CONTRIBUTING.md', 'CONTRIBUTING.txt')
    }

    from('LICENSE')
    from('NOTICE')

    from('src/template/VERSION.md') {
        expand(buildNumber: env.BUILD_NUMBER, buildUrl: env.BUILD_URL, gitBranch: convertGitBranch(env.GIT_BRANCH),
                dateTime: startDateTimeString, displayVersion: displayVersion)
        rename('VERSION.md', 'VERSION.txt')
    }

    into "$buildDir/distributions"
}

task copyExtraIntoResources(type: Copy) {
    from('README.md')
    from('CHANGELOG.md')
    from('CONTRIBUTING.md')
    from('LICENSE')
    from('NOTICE')

    into('src/main/resources/org/terasology/launcher/about')
}
processResources.dependsOn copyExtraIntoResources

task copyIconsIntoResources(type: Copy) {
    from('icons')

    into('src/main/resources/org/terasology/launcher/icons')
}
processResources.dependsOn copyIconsIntoResources

// TODO: Temporary workaround for new exes / JRE bundling not quite being officially ready yet
distZip.exclude("*.x*.exe")

task createRelease() {
    dependsOn distZip

    doLast {
        println 'Created release: ' + displayVersion
    }
}

task createPatch(dependsOn: distZip) {
    description = 'Create a delta patch file w.r.t. last successful build of given JOB_NAME (must be set)'
    if (env.JOB_NAME == null) {
        logger.info("No JOB_NAME given, skipping ...")
        return
    }

    doLast {
        File patchDir = new File(buildDir, 'patch/')
        File distDir = new File(buildDir, 'distributions/')

        String lastSuccessfulBuildNumber = "http://jenkins.terasology.org/job/$env.JOB_NAME/lastSuccessfulBuild/buildNumber".toURL().getText()
        String url = "http://jenkins.terasology.org/job/$env.JOB_NAME/lastSuccessfulBuild/artifact/build/distributions/TerasologyLauncher.zip"

        File oldZip = new File(patchDir, 'old.zip')
        File newZip = new File(distDir, 'TerasologyLauncher.zip')

        // Download the last successful build artifact for the current job
        download {
            onlyIfNewer true
            src url
            dest oldZip
        }

        // Unzip the last successful build into the 'old' directory
        copy {
            from zipTree(oldZip)
            into new File(patchDir, 'old/')
        }

        // Unzip the result of this build into the 'new' directory
        copy {
            from zipTree(newZip)
            into new File(patchDir, 'new/')
        }

        File oldUnzipped = new File(patchDir, 'old/TerasologyLauncher/')
        File newUnzipped = new File(patchDir, 'new/TerasologyLauncher/')

        String patchFileName = "$project.name-patch-$env.JOB_NAME-$lastSuccessfulBuildNumber-$env.BUILD_NUMBER" + ".zip"
        File patchZip = new File(patchDir, patchFileName)

        logger.info("Creating patch file with: \n\told  : $oldUnzipped\n\tnew  : $newUnzipped\n\tpatch: $patchZip")
        new com.alexkasko.delta.DirDeltaCreator().create(oldUnzipped, newUnzipped, patchZip)

        // Copy the patch file artifact to the 'distributions' directory
        copy {
            from patchZip
            into distDir
        }

        println "Created patch: $patchFileName"
    }
}
